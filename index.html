<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Web RTC</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<section style="text-align: center">
						<h1>Structural Pattern</h1>
					</section>
					<section style="text-align: center">
						<p>작은 클래스들을 합성하여</p> 
						<p>더 큰 구조의 클래스를 형성하는데 사용되는 패턴</p>
					</section>
				</section>
				<section>
					<section style="text-align: center">
						<h1>contents</h1>
						<p>1. Adapter Pattern</p>
						<p>2. Bridge Pattern</p>
						<p>3. Composite Pattern</p>
						<p>4. Decorator Pattern</p>
					</section>
				</section>
				<section>
					<section style="text-align: center">
						<h2>1. Adapter Pattern</h2>
					</section>
					<section style="text-align: center">
						<p>서로 다른 인터페이스를 가진 클래스들이</p>
						<p>호환될 수 있도록 맞춰주는 패턴</p>
					</section>
					<section style="text-align: center">
						<h2>화면에 그림을 그려주는 클래스</h2>
						<p class="fade-in-then-fade-out">
							<p>Pen 클래스의 그리는 함수: draw()</p>
							<p >Paint 클래스의 그리는 함수: paint()</p>
						</p>
						<h3 class="fragment fade-in">공통 인터페이스 render()</h3>
					</section>
					<section style="text-align: center">
						<h2>Class Adapter</h2>
						<p>상속을 사용한 Adapter 구현</p>
					</section>
					<section style="text-align: center">
						<img src="images/class-adapter.gif" width="840" height="260">
						<p>Adaptee 클래스를 상속받아서 사용</p>
					</section>
					<section style="text-align: center">
						<h2>장점</h2>
						<p>Pen 의 기능을 재 정의 할 수 있다.</p>
					</section>
					<section style="text-align: center">
						<h2>단점</h2>
						<p>Pen, Paint, Spray.. 여러 개일 경우? 다중 상속?</p>
						<p>Black Pen, Highlight Pen.. Pen의 세부 클래스가 있을 경우 사용 불가</p>
					</section>
					<section style="text-align: center">
						<h2>Object Adapter</h2>
						<p>객체 합성을 사용한 Adapter 구현</p>
					</section>
					<section style="text-align: center">
						<img src="images/object-adapter.gif" width="840" height="260">
						<p>Adaptee 객체를 Refer 하고 있다.</p>
					</section>
					<section style="text-align: center">
						<h2>장점</h2>
						<p>Pen, Paint, Spray등 여러 개의 사용 가능</p>
						<p>Pen을 상속하는 Black Pen, Highlight Pen 모두 사용 가능</p>
					</section>
					<section style="text-align: center">
						<h2>단점</h2>
						<p>Pen의 기능 재정의 불가능</p>
					</section>
				</section>
				<section>
					<section style="text-align: center">
						<h2>2. Bridge Pattern</h2>
					</section>
					<section style="text-align: center">
						<p>2개의 구체 클래스 간의 강한 결합을 제거하는 패턴</p>
						<p>(분기 안에 분기가 있는 경우 사용)</p>
					</section>
					<section style="text-align: center">
						<h2>여러 개의 유닛: 전사, 궁수</h2>
						<h2>여러 개의 무기: 칼, 활</h2>
						<p>전사가 칼을 사용하는 경우 구현</p>
						<p>궁수가 칼을 사용하는 경우 구현</p>
						<p>유닛 추가 될 때마다 칼을 사용 기능을 모두 구현 해야 하나??</p>
					</section>
					<section style="text-align: center">
						<img src="images/class-adapter.gif" width="840" height="260">
						<p>구현 클래스에서 추상 개념을 분리하여 서로 독립적으로 변화 할 수 있도록 함 </p>
						<p>각각 인터페이스로 분리 (Abstraction, Implementor)</p>
					</section>
					<section style="text-align: center">
						<h2>특징</h2>
						<p>런타임에 칼 또는 활 선택 가능 (구현 클래스 선택 가능)</p>
						<p>새로운 유닛 추가시 안전함 (서로 영향을 주지 않음)</p>
					</section>
					<section style="text-align: center">
						<h2>관련 클래스</h2>
						<p>Abstract Factory 패턴과 자주 같이 사용된다.</p>
					</section>
				</section>
				<section>
					<section style="text-align: center">
						<h2>3. Composite Pattern</h2>
					</section>
					<section style="text-align: center">
						<p>개별 객체와 복합 객체를</p>
						<p>동일하게 다루게 해주는 패턴</p>
					</section>
					<section style="text-align: center">
						<p>마린 1마리를 이동할 때</p>
						<p>마린 1부대를 한꺼번에 이동할 때</p>
					</section>
					<section style="text-align: center">
						<img src="images/composite-pattern.png" width="840" height="260">
						<p>개별 객체와 복합 객체간의 공통인터페이스를 추출하여 사용</p>
						<p>복합 객체가 객체들을 가지고 있는 자료구조는 자유: List, HashMap, etc..</p>
					</section>
				</section>
				<section>
					<section style="text-align: center">
						<h2>4. Decorator Pattern</h2>
					</section>
					<section style="text-align: center">
					</section>
				</section>
				<section>
					<section style="text-align: center">
						<h2>Web RTC 데모</h2>
					</section>
					<section style="text-align: center">
						<a href="https://ec2-13-125-27-27.ap-northeast-2.compute.amazonaws.com">Web RTC 데모(Chrome)</a>
						<img src="images/demo.png" width="640" height="420">
					</section>
				</section>
				<section style="text-align: left;">
					<h1>THE END</h1>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
